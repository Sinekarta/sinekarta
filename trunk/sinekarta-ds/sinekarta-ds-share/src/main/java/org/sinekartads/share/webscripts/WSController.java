/*
/*
 * Copyright (C) 2010 - 2012 Jenia Software.
 *
 * This file is part of Sinekarta
 *
 * Sinekarta is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Sinekarta is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
package org.sinekartads.share.webscripts;

import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

import org.apache.commons.lang.StringUtils;
import org.sinekartads.dto.DTOFormatter;
import org.sinekartads.dto.ResultCode;
import org.sinekartads.dto.share.WizardDTO;
import org.sinekartads.dto.share.WizardDTO.WizardStepDTO;
import org.sinekartads.dto.tools.DTOConverter;
import org.sinekartads.share.ShareConfiguration;
import org.sinekartads.share.util.AlfrescoException;
import org.sinekartads.util.TemplateUtils;
import org.springframework.core.GenericTypeResolver;
import org.springframework.extensions.surf.util.I18NUtil;
import org.springframework.extensions.webscripts.Cache;
import org.springframework.extensions.webscripts.Status;
import org.springframework.extensions.webscripts.WebScriptRequest;

public abstract class WSController<DTO extends WizardDTO> extends BaseWS {
	
	// -----
	// --- Communication with the form
	// -

	/**
	 * Unique ID of the HTML page hosting the JS controller, automatically generated by Alfresco
	 * Share and continuosly exchanged between the two controllers without being ever modified.<br/>
	 * Used both as input and output parameter in order to allow a standard widgets id generation 
	 * policy and grant in that way the JS controller to be able to retrieve them.
	 */
	public static final String IO_HTMLID = "htmlid";
	
	/**
	 * Back-page return URL. When the documentLibrary performs the first wizard webScript call, it
	 * takes the current URL and send it to the WS controller. This value will be then continuosly
	 * exchanged between the two controllers without being ever modified.<br/>
	 * Used both as input and output parameter in order to allow the JS controller to return to the
	 * calling page when the wizard execution succeed or has been aborted by the user.
	 */
	public static final String IO_BACKURL = "backUrl";
	
	public static final String RC_SUCCESS = "SUCCESS";
	public static final String RC_ERROR = "ERROR";
	
	public static final String IO_WIZARDJSON	= "wizardDataJSON";
	
	/**
	 * Wizard data transport object. <br/>
	 * Received as JSON input from the jsController
	 */
	public static final String OUT_WIZARDDATA	= "wscWizardData";
	
	/**
	 * User data error communication unit.
	 * At the beginning of the form process phase, the WS controller validates the received
	 * user data. Any error, such as a missing mandatory field, will halt the execution and
	 * be reported to the form with the <i>fieldErrors</i> output parameter using the JSON
	 * format: <pre>
	 * 		[
	 *			[ field_0, [ error_0_0 ] ]
	 *			[ field_1, [ error_1_0, error_1_1, error_1_2 ] ]
	 *			[ field_2, [ error_2_0, error_0_1 ] ]
	 *			...
	 *		]
	 * </pre>
	 * Used as output parameter.
	 */
//	public static final String OUT_FIELD_ERRORS	  =	"fieldErrors";

	/**
	 * Generic user and system error communication unit.
	 * Any error that do not regard a form field will be shown into the top section of the
	 * wizard page. Those will be communicated to the JS controller with the JSON format: <pre>
	 * 		[
	 * 			[ errorMessage: errorMessage_0, errorCause: errorCause_0 ]
	 * 			[ errorMessage: errorMessage_1, errorCause: errorCause_1 ]
	 * 			[ errorMessage: errorMessage_2, errorCause: errorCause_2 ]
	 * 			...
	 * 		]
	 * </pre>
	 * Used as output parameter.
	 */
//	public static final String OUT_ACTION_ERRORS  = "actionErrors";
	public static final String AE_ERROR_MESSAGE = "errorMessage";
	public static final String AE_ERROR_CAUSE = "errorCause";
	
	
	
	// -----
	// --- Required bundle resources
	// -

	// LABELS - dictionary of the system labels, have to be declared into the bundle in any format
	public static final String MANDATORY  	  = "mandatory";
	
	// ERRORS - dictionary of the known errors, have to be declared into the bundle
	//		Any error into sineKarta platform is expected to appear with the form error.<type>, such as
	//				- error.generic = Errore generico!
	//				  [...]
	public static final String GENERIC_ERROR  = "error.generic";
	
	// RESULT_CODES - format for the Alfresco communication result codes
	// 		Any result code needs a translation into the bundle with the format resultCode.<type>, such as
	//				- resultCode.SUCCESS = OK
	//				- resultCode.INTERNAL_CLIENT_ERROR = Errore generico lato Share.
	//				  [...]
	public static final String RESULT_CODE 	  = "resultCode.%s";

	
	
	// -----
	// --- Shared tools and data
	// -
	
	protected final ShareConfiguration conf = ShareConfiguration.getInstance();
	protected final DTOConverter converter = DTOConverter.getInstance();
	

	
	// -----
	// --- WizardDTO class recognization
	// -
	
	private final Class<? extends WizardDTO> dtoClass;
	
	@SuppressWarnings("unchecked")
	protected WSController ( ) {
		Class<?>[] typeArgs = GenericTypeResolver.resolveTypeArguments(getClass(), WSController.class);
		Class<WizardDTO> clazz = null;
		for (Class<?> typeArg : typeArgs) {
			if (WizardDTO.class.isAssignableFrom(typeArg)) {
				clazz = (Class<WizardDTO>) typeArg;
			}
		}
		if(clazz == null) {
			throw new RuntimeException("unable to recognize the dtoClass");
		}
		dtoClass = clazz;
	}

	
	
	// ----- 
	// --- WebScript protocol
	// -
	
	@SuppressWarnings("unchecked")
	@Override
	public Map<String, Object> executeImpl (
			WebScriptRequest req, 
			Status status, 
			Cache cache ) {
		
		Map<String, Object> model = new HashMap<String, Object>();
		String jscWizardData = getParameter ( req, IO_WIZARDJSON );
		String htmlid 		 = getParameter ( req, IO_HTMLID );
		DTO    wizardData	 = null;

		try {
			// Retrieve the WizardDTO instance
			wizardData = (DTO) TemplateUtils.Encoding.deserializeJSON ( dtoClass, jscWizardData );

			// Process the wizardData
			processData ( wizardData );
		} catch(Exception e) {
			processError ( wizardData, e );
		} finally {
			// Select the currentForm to be displayed by the JS controller 
			WizardStep currentForm;
			boolean success =  StringUtils.equals ( 
					wizardData.getResultCode(), WizardDTO.SUCCESS );
			if ( success ) {
				currentForm = nextStep ( currentStep() );
			} else {
				currentForm = currentStep();
			}
			wizardData.setCurrentStep ( toWizardStepDTO(currentForm) );
			wizardData.setWizardSteps ( toWizardStepDTO(getWizardSteps()) );
			wizardData.setWizardForms ( getWizardForms() );
			
			// Send the htmlid back only if it has been previously populated by Alfresco share
			if ( StringUtils.isNotBlank(htmlid) ) {
				model.put ( IO_HTMLID, htmlid );
			}
			
			// Send the other output parameters to the JS controller
			model.put ( IO_WIZARDJSON,     wizardData.toJSON() );
			model.put ( OUT_WIZARDDATA,    wizardData );
		}
		return model;
	}
	
	protected void processError ( DTO wizardData, String errorMessage ) {
		processError ( wizardData, errorMessage, null );
	}
	
	protected void processError ( DTO wizardData, Exception errorCause ) {
		processError ( wizardData, null, errorCause );
	}
	
	protected void processError ( DTO wizardData, String errorMessage, Exception errorCause ) {
		if ( StringUtils.isBlank(errorMessage) ) {
			if ( errorCause instanceof AlfrescoException ) { 
				errorMessage = errorCause.getMessage();
				if ( StringUtils.isBlank(errorMessage) ) {
					ResultCode resultCode = ((AlfrescoException)errorCause).getResultCode();
					errorMessage = getMessage ( String.format(RESULT_CODE, resultCode) );
				}
			}
		}
		
		wizardData.addActionError ( errorMessage, errorCause );
	}

	protected abstract void processData ( 
			DTO wizardDto ) 
					throws AlfrescoException ;
	
	protected WizardStep nextStep ( WizardStep step ) {
		if ( step == null )											return null; 
		int stepIndex = stepIndex ( step );
		int prevIdx = stepIndex < getWizardSteps().length-1 ? stepIndex+1 : stepIndex;   
		return getWizardSteps() [ prevIdx ];
	}
	
	private int stepIndex ( WizardStep step ) {
		WizardStep[] wizardSteps = getWizardSteps();
		int stepIndex = -1;
		for ( int idx=0; idx<wizardSteps.length && stepIndex==-1; idx++ ) {
			if ( step.equals(wizardSteps[idx]) ) {
				stepIndex = idx;
			}
		}
		if ( stepIndex == -1 ) {
			throw new UnsupportedOperationException ( 
					String.format ( "Page form not found - %s \nThe known wizard steps are: %s", 
								    step, StringUtils.join(wizardSteps) ) );
		}
		return stepIndex;
	}

	public static class WizardStep {
		
		public WizardStep ( String name, String form ) {
			this.name = name;
			this.form = form;
		}
		
		public boolean equals ( WizardStep step ) {
			return StringUtils.equals ( name, step.name );
		}
		
		final String name;
		final String form; 
	}

	protected abstract String[] getWizardForms ( ) ;
	
	protected abstract WizardStep[] getWizardSteps ( ) ;
	
	protected abstract WizardStep currentStep ( ) ;
	
	private WizardStepDTO[] toWizardStepDTO ( WizardStep[] wizardSteps ) {
		WizardStepDTO[] dtos  = new WizardStepDTO[wizardSteps.length];
		for ( int i=0; i<wizardSteps.length; i++ ) {
			dtos[i] = toWizardStepDTO ( wizardSteps[i] );
		}
		return dtos;
	}
	
	private WizardStepDTO toWizardStepDTO ( WizardStep wizardStep ) {
		if ( wizardStep == null )										return null;
		WizardStepDTO dto = new WizardStepDTO();
		dto.setName(wizardStep.name);
		dto.setForm(wizardStep.form);
		return dto;
	}
	
	
	
	// -----
	// --- DTO format
	// -
	
	private Map<Locale, DTOFormatter> dtoFormatters = new HashMap<Locale, DTOFormatter>();
	
	protected DTOFormatter getDtoFormatter() {
		Locale locale = I18NUtil.getLocale();
		DTOFormatter dtoFormatter = dtoFormatters.get(locale);
		if(dtoFormatter == null) {
			dtoFormatter = new DTOFormatter(getResources());
			dtoFormatter.loadFormats(ResourceBundle.getBundle("alfresco/messages/skds-commons.properties"));
			dtoFormatters.put(locale, dtoFormatter);
		}
		return dtoFormatter;
	}
	
	
	
	// -----
	// --- Error management
	// -
	
	protected void addFieldError( DTO dto, String field, String error ) {
		dto.addFieldError(field, error);
	}
}