/*
/*
 * Copyright (C) 2010 - 2012 Jenia Software.
 *
 * This file is part of Sinekarta
 *
 * Sinekarta is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Sinekarta is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
package org.sinekartads.share.webscripts;

import java.io.ByteArrayOutputStream;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

import net.sf.json.JSONObject;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.sinekartads.dto.DTOFormatter;
import org.sinekartads.dto.ResultCode;
import org.sinekartads.dto.share.WizardDTO;
import org.sinekartads.dto.tools.DTOConverter;
import org.sinekartads.share.ShareConfiguration;
import org.sinekartads.share.util.AlfrescoException;
import org.sinekartads.util.TemplateUtils;
import org.springframework.core.GenericTypeResolver;
import org.springframework.extensions.surf.util.I18NUtil;
import org.springframework.extensions.webscripts.Cache;
import org.springframework.extensions.webscripts.Status;
import org.springframework.extensions.webscripts.WebScriptRequest;

public abstract class WSController<DTO extends WizardDTO> extends BaseWS {
	
	// -----
	// --- Communication with the form
	// -

	/**
	 * Unique ID of the HTML page hosting the JS controller, automatically generated by Alfresco
	 * Share and continuosly exchanged between the two controllers without being ever modified.<br/>
	 * Used both as input and output parameter in order to allow a standard widgets id generation 
	 * policy and grant in that way the JS controller to be able to retrieve them.
	 */
	public static final String IO_HTMLID = "htmlid";
	
	/**
	 * Back-page return URL. When the documentLibrary performs the first wizard webScript call, it
	 * takes the current URL and send it to the WS controller. This value will be then continuosly
	 * exchanged between the two controllers without being ever modified.<br/>
	 * Used both as input and output parameter in order to allow the JS controller to return to the
	 * calling page when the wizard execution succeed or has been aborted by the user.
	 */
	public static final String IO_BACKURL = "backUrl";
	
	/**
	 * Page operation required by the JS controller to the WS controller - {@link #OPR_PREPARE} 
	 * or {@link #OPR_PROCESS}. <br/>
	 * Default value when unspecified: {@link #OPR_PREPARE}.
	 * Used as input parameter in order to drive the WS execution. 
	 */
	public static final String IN_PAGEOPERATION = "pageOperation";
	
	public static final String OPR_PREPARE = "prepare";
	public static final String OPR_PROCESS = "process";

	
	public static final String IO_WIZARDJSON	= "wizardDataJSON";
	
	/**
	 * Wizard data transport object. <br/>
	 * Received as JSON input from the jsController
	 */
	public static final String OUT_WIZARDDATA	= "wscWizardData";
	
	/**
	 * User data error communication unit.
	 * At the beginning of the form process phase, the WS controller validates the received
	 * user data. Any error, such as a missing mandatory field, will halt the execution and
	 * be reported to the form with the <i>fieldErrors</i> output parameter using the JSON
	 * format: <pre>
	 * 		[
	 *			[ field_0, [ error_0_0 ] ]
	 *			[ field_1, [ error_1_0, error_1_1, error_1_2 ] ]
	 *			[ field_2, [ error_2_0, error_0_1 ] ]
	 *			...
	 *		]
	 * </pre>
	 * Used as output parameter.
	 */
//	public static final String OUT_FIELD_ERRORS	  =	"fieldErrors";

	/**
	 * Generic user and system error communication unit.
	 * Any error that do not regard a form field will be shown into the top section of the
	 * wizard page. Those will be communicated to the JS controller with the JSON format: <pre>
	 * 		[
	 * 			[ errorMessage: errorMessage_0, errorCause: errorCause_0 ]
	 * 			[ errorMessage: errorMessage_1, errorCause: errorCause_1 ]
	 * 			[ errorMessage: errorMessage_2, errorCause: errorCause_2 ]
	 * 			...
	 * 		]
	 * </pre>
	 * Used as output parameter.
	 */
//	public static final String OUT_ACTION_ERRORS  = "actionErrors";
	public static final String AE_ERROR_MESSAGE = "errorMessage";
	public static final String AE_ERROR_CAUSE = "errorCause";
	
	
	
	// -----
	// --- Required bundle resources
	// -

	// LABELS - dictionary of the system labels, have to be declared into the bundle in any format
	public static final String MANDATORY  	  = "mandatory";
	
	// ERRORS - dictionary of the known errors, have to be declared into the bundle
	//		Any error into sineKarta platform is expected to appear with the form error.<type>, such as
	//				- error.generic = Errore generico!
	//				  [...]
	public static final String GENERIC_ERROR  = "error.generic";
	
	// RESULT_CODES - format for the Alfresco communication result codes
	// 		Any result code needs a translation into the bundle with the format resultCode.<type>, such as
	//				- resultCode.SUCCESS = OK
	//				- resultCode.INTERNAL_CLIENT_ERROR = Errore generico lato Share.
	//				  [...]
	public static final String RESULT_CODE 	  = "resultCode.%s";

	
	
	// -----
	// --- Shared tools and data
	// -
	
	private static 	final Logger tracer = Logger.getLogger(WSController.class);
	protected final ShareConfiguration conf = ShareConfiguration.getInstance();
	protected final DTOConverter converter = DTOConverter.getInstance();
	

	
	// -----
	// --- WizardDTO class recognization
	// -
	
	private final Class<? extends WizardDTO> dtoClass;
	
	@SuppressWarnings("unchecked")
	protected WSController ( ) {
		Class<?>[] typeArgs = GenericTypeResolver.resolveTypeArguments(getClass(), WSController.class);
		Class<WizardDTO> clazz = null;
		for (Class<?> typeArg : typeArgs) {
			if (WizardDTO.class.isAssignableFrom(typeArg)) {
				clazz = (Class<WizardDTO>) typeArg;
			}
		}
		if(clazz == null) {
			throw new RuntimeException("unable to recognize the dtoClass");
		}
		dtoClass = clazz;
	}

	
	
	// ----- 
	// --- WebScript protocol
	// -
	
	@SuppressWarnings("unchecked")
	@Override
	public Map<String, Object> executeImpl (
			WebScriptRequest req, Status status, Cache cache ) {
		
		Map<String, Object> model = new HashMap<String, Object>();
		fieldErrors = new HashMap<String, List<String>>();
		actionErrors = new ArrayList<String>();

		String jscWizardData = getParameter ( req, IO_WIZARDJSON );
		String htmlid 		 = getParameter ( req, IO_HTMLID );
		String formOperation = null;
		DTO    wizardData	 = null;

		try {
			// Retrieve the WizardDTO instance 						- generate it if missing
			if ( StringUtils.isBlank(jscWizardData) ) {
				wizardData = (DTO) dtoClass.getConstructor ( new Class<?>[0]).newInstance(new Object[0] );
				wizardData.setBackUrl( getParameter(req, IO_BACKURL) );
			} else {
				wizardData = (DTO) TemplateUtils.Encoding.deserializeJSON ( dtoClass, jscWizardData );
			}
	
			// Evaluate the input status 							- PREPARE if missing
			formOperation = wizardData.getFormOperation();
			if ( StringUtils.isBlank(formOperation) ) {
				formOperation = OPR_PREPARE;
			}
			
			// Execute the operation required by the JS controller
			switch ( formOperation ) {
				case OPR_PROCESS: {
					// Process the received form data
					try {
						processForm ( req, wizardData );
						break;
					} catch ( Exception e ) {
						processError ( e );
						// If there has been a failure, go on into the switch and prepare the form data again
					}
				}
				case OPR_PREPARE: {
					// Prepare the data to be sent to the form - if it has not been successfully processed yet
					try {
						prepareForm( req, wizardData);
					} catch ( Exception e ) {
						processError ( e );
					}
					break;
				}
				default: {
					try {
						performExtraOperation( req, wizardData, formOperation ); 
					} catch ( Exception e ) {
						processError ( e );
					}
				}
			}
		} catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
			addActionError ( String.format("invalid wizardDTO - %s", e.getMessage()), e, false );
		} catch (RuntimeException e) {
			addActionError ( e );
		} finally {
			
			// Select the currentForm to be displayed by the JS controller 
			String currentForm = currentForm();
			boolean success =  fieldErrors.isEmpty() && actionErrors.isEmpty();
			if ( StringUtils.equals(formOperation, OPR_PREPARE) ) {
				if ( success ) {
					wizardData.setCurrentForm ( currentForm );
				} else {
					wizardData.setCurrentForm ( prevForm(currentForm) );
				}
			} else if ( StringUtils.equals(formOperation, OPR_PROCESS) ) {
				if ( success ) {
					wizardData.setCurrentForm ( nextForm(currentForm) );
				} else {
					wizardData.setCurrentForm ( currentForm );
				}
			}
			wizardData.setWizardForms ( getWizardForms() );
			wizardData.setActionErrors(actionErrors);
			wizardData.setFieldErrors(fieldErrors);
			
			// Send the htmlid back only if it has been previously populated by Alfresco share
			if ( StringUtils.isNotBlank(htmlid) ) {
				model.put ( IO_HTMLID, htmlid );
			}
			
			// Send the other output parameters to the JS controller
			// TODO move action and field errors inside the json
			model.put ( IO_WIZARDJSON,     wizardData.toJSON() );
			model.put ( OUT_WIZARDDATA,    wizardData );
		}
		return model;
	}
	
	protected void processError ( Exception errorCause ) {
		String errorMessage;
		if ( errorCause instanceof AlfrescoException ) { 
			errorMessage = errorCause.getMessage();
			if ( StringUtils.isBlank(errorMessage) ) {
				ResultCode resultCode = ((AlfrescoException)errorCause).getResultCode();
				errorMessage = getMessage ( String.format(RESULT_CODE, resultCode) );
			}
			addActionError ( errorMessage, errorCause, true );
		} else {
			addActionError ( errorCause );
		}
	}
	
	protected abstract void prepareForm (
			WebScriptRequest req, 
			DTO wizardDto ) 
					throws AlfrescoException ;
	
	protected abstract void processForm ( 
			WebScriptRequest req, 
			DTO wizardDto ) 
					throws AlfrescoException ;
	
	protected void performExtraOperation( 
			WebScriptRequest req, DTO wizardDto, String formOperation ) 
					throws AlfrescoException  {
		// Any other input page status comes from a wrong JS controller choice 
		throw new IllegalArgumentException ( 
				String.format("unexpected form operation: %s", formOperation) );
	}

	protected String prevForm ( String currentForm ) {
		int formIndex = formIndex ( currentForm );
		int prevIdx = formIndex > 0 ? formIndex-1 : formIndex;   
		return getWizardForms() [ prevIdx ];
	}
	
	protected String nextForm ( String currentForm ) {
		int formIndex = formIndex ( currentForm );
		int prevIdx = formIndex < getWizardForms().length-1 ? formIndex+1 : formIndex;   
		return getWizardForms() [ prevIdx ];
	}
	
	private int formIndex ( String currentForm ) {
		String[] wizardForms = getWizardForms();
		int formIndex = -1;
		for ( int idx=0; idx<wizardForms.length && formIndex==-1; idx++ ) {
			if ( StringUtils.equals(currentForm, wizardForms[idx]) ) {
				formIndex = idx;
			}
		}
		if ( formIndex == -1 ) {
			throw new UnsupportedOperationException ( 
					String.format ( "Page form not found - %s \nThe known wizard steps are: %s", 
								    currentForm, StringUtils.join ( wizardForms) ) );
		}
		return formIndex;
	}
	
	protected abstract String[] getWizardForms ( ) ;
	
	protected abstract String currentForm ( ) ;
	
	
	
	// -----
	// --- DTO format
	// -
	
	private Map<Locale, DTOFormatter> dtoFormatters = new HashMap<Locale, DTOFormatter>();
	
	protected DTOFormatter getDtoFormatter() {
		Locale locale = I18NUtil.getLocale();
		DTOFormatter dtoFormatter = dtoFormatters.get(locale);
		if(dtoFormatter == null) {
			dtoFormatter = new DTOFormatter(getResources());
			dtoFormatter.loadFormats(ResourceBundle.getBundle("alfresco/messages/skds-commons.properties"));
			dtoFormatters.put(locale, dtoFormatter);
		}
		return dtoFormatter;
	}
	
	
	
	// -----
	// --- Error management
	// -
	
	protected List<String> actionErrors;
	protected Map<String, List<String>> fieldErrors;
	
	protected void addFieldError( String field, String error ) {
		List<String> errors = fieldErrors.get(field);
		if(errors == null) {
			errors = new ArrayList<String>();
			fieldErrors.put(field, errors);
		}
		errors.add(error);
	}
	
	protected void addActionError ( String errorMessage ) {
		addActionError(errorMessage, null, false);
	}
	
	protected void addActionError ( Throwable errorCause ) {
		addActionError(null, errorCause, true);
	}
	
	protected void addActionError ( 
			String errorMessage, Throwable errorCause, boolean displayStackTrace ) {

		// Prepare the actionError as a JSON object
		JSONObject json = new JSONObject();
		
		// Push the errorMessage into the actionError 
		if ( StringUtils.isEmpty(errorMessage) ) {
			// Evaluate a default errorMessage if missing 			- typically, errorCause-only override
			if ( errorCause != null ) {
				errorMessage = errorCause.getMessage();
				if ( StringUtils.isBlank(errorMessage) ) {
					json.put ( AE_ERROR_MESSAGE, errorCause.getClass().getName() );
				} else {
					json.put ( AE_ERROR_MESSAGE, 
							String.format("%s - %s", errorCause.getClass().getName(), errorMessage) );
				}
			} else {
				json.put ( AE_ERROR_MESSAGE, getMessage(GENERIC_ERROR) );
			}
		} else {
			// Let the errorMesage as is if provided				- typically, errorMessage-only override
			json.put ( AE_ERROR_MESSAGE, errorMessage );
		}
		
		// Push the errorCause into the actionError, if provided
		if ( errorCause != null && displayStackTrace ) {
			ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
			PrintWriter writer = new PrintWriter(baos);
			errorCause.printStackTrace(writer);
			writer.flush();
			String stackTrace = new String(baos.toByteArray()); 
			json.put ( AE_ERROR_CAUSE, stackTrace );
		}
		
		// Add the actionError JSON to the inner list				- it will be sent to form when the webScript ends
		tracer.error(errorMessage, errorCause);
		actionErrors.add ( json.toString() );
	}
}